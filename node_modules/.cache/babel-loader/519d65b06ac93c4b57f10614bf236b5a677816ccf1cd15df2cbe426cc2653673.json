{"ast":null,"code":"// ClippIntell Bot Detection MVP - Core Bot Detection Engine\n\n// Social media data scraper (mock for MVP)\nclass SocialMediaScraper {\n  async scrapeAccountData(account) {\n    // In production, this would scrape real data\n    // For MVP, we'll generate realistic mock data based on platform\n\n    const platformMultipliers = {\n      instagram: {\n        followers: 1,\n        engagement: 0.03\n      },\n      tiktok: {\n        followers: 1.5,\n        engagement: 0.08\n      },\n      youtube: {\n        followers: 0.7,\n        engagement: 0.05\n      },\n      twitter: {\n        followers: 0.8,\n        engagement: 0.02\n      }\n    };\n    const multiplier = platformMultipliers[account.platform];\n    const baseFollowers = Math.floor(Math.random() * 30000 + 500) * multiplier.followers;\n    const baseMetrics = {\n      followers: Math.floor(baseFollowers),\n      following: Math.floor(Math.random() * 3000 + 100),\n      posts: Math.floor(Math.random() * 300 + 10),\n      avgLikes: 0,\n      avgComments: 0,\n      engagementRate: 0,\n      followerToFollowingRatio: 0\n    };\n\n    // Platform-specific metrics\n    if (account.platform === 'tiktok' || account.platform === 'youtube') {\n      baseMetrics.avgViews = Math.floor(baseMetrics.followers * (Math.random() * 0.3 + 0.1));\n    }\n\n    // Calculate realistic engagement\n    const targetEngagement = multiplier.engagement + (Math.random() - 0.5) * 0.02;\n    baseMetrics.avgLikes = Math.floor(baseMetrics.followers * targetEngagement);\n    baseMetrics.avgComments = Math.floor(baseMetrics.avgLikes * (Math.random() * 0.15 + 0.05));\n    baseMetrics.engagementRate = (baseMetrics.avgLikes + baseMetrics.avgComments) / baseMetrics.followers * 100;\n    baseMetrics.followerToFollowingRatio = baseMetrics.followers / baseMetrics.following;\n\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));\n    return baseMetrics;\n  }\n}\n\n// AI-powered bot detection analyzer\nexport class BotAnalyzer {\n  constructor() {\n    this.scraper = void 0;\n    this.scraper = new SocialMediaScraper();\n  }\n  async analyzeAccount(account) {\n    const startTime = Date.now();\n    try {\n      console.log(`Starting analysis for ${account.handle} on ${account.platform}`);\n\n      // Step 1: Scrape account metrics\n      const metrics = await this.scraper.scrapeAccountData(account);\n      console.log('Scraped metrics:', metrics);\n\n      // Step 2: AI analysis using Gemini\n      const aiAnalysis = await this.performAIAnalysis(account, metrics);\n      console.log('AI analysis complete:', aiAnalysis);\n\n      // Step 3: Calculate bot score and risk level\n      const botScore = this.calculateBotScore(metrics, aiAnalysis.signals);\n      const riskLevel = this.determineRiskLevel(botScore);\n\n      // Step 4: Generate recommendations\n      const redFlags = this.identifyRedFlags(metrics, aiAnalysis.signals);\n      const recommendations = this.generateRecommendations(riskLevel, redFlags);\n      const processingTime = (Date.now() - startTime) / 1000;\n      const result = {\n        id: this.generateAnalysisId(),\n        account,\n        botScore,\n        riskLevel,\n        signals: aiAnalysis.signals,\n        metrics,\n        redFlags,\n        recommendations,\n        confidence: aiAnalysis.confidence,\n        analysisDate: new Date().toISOString(),\n        processingTime\n      };\n      console.log('Analysis complete:', result);\n      return result;\n    } catch (error) {\n      console.error('Bot analysis failed:', error);\n      throw new Error(`Analysis failed for ${account.handle}: ${error.message}`);\n    }\n  }\n  async performAIAnalysis(account, metrics) {\n    try {\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY_1;\n      if (!apiKey) {\n        console.log('No Gemini API key found, using fallback analysis');\n        return this.fallbackAnalysis(metrics);\n      }\n      const genAI = new GoogleGenerativeAI(apiKey);\n      const model = genAI.getGenerativeModel({\n        model: \"gemini-pro\"\n      });\n      const prompt = this.createAnalysisPrompt(account, metrics);\n      console.log('Sending prompt to Gemini AI...');\n      const result = await model.generateContent(prompt);\n      const response = await result.response;\n      const analysisText = response.text();\n      console.log('AI response received:', analysisText);\n\n      // Parse AI response\n      return this.parseAIResponse(analysisText, metrics);\n    } catch (error) {\n      console.error('AI analysis failed:', error);\n      // Fallback to rule-based analysis\n      console.log('Using fallback rule-based analysis');\n      return this.fallbackAnalysis(metrics);\n    }\n  }\n  createAnalysisPrompt(account, metrics) {\n    return `\nAnalyze this ${account.platform} account for bot-like behavior:\n\nAccount: ${account.handle}\nPlatform: ${account.platform}\n\nMetrics:\n- Followers: ${metrics.followers}\n- Following: ${metrics.following}\n- Posts: ${metrics.posts}\n- Avg Likes: ${metrics.avgLikes}\n- Avg Comments: ${metrics.avgComments}\n- Engagement Rate: ${metrics.engagementRate.toFixed(2)}%\n- Follower/Following Ratio: ${metrics.followerToFollowingRatio.toFixed(2)}\n\nAnalyze these bot indicators and respond ONLY with valid JSON:\n\n{\n  \"followerQuality\": \"normal|suspicious|fake\",\n  \"engagementPattern\": \"organic|automated|suspicious\", \n  \"contentConsistency\": \"good|poor|inconsistent\",\n  \"accountAge\": \"established|recent|very_new\",\n  \"profileCompleteness\": \"complete|incomplete|minimal\",\n  \"confidence\": 85\n}\n`;\n  }\n  parseAIResponse(response, metrics) {\n    try {\n      // Try to extract JSON from AI response\n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[0]);\n        return {\n          signals: {\n            followerQuality: parsed.followerQuality || 'normal',\n            engagementPattern: parsed.engagementPattern || 'organic',\n            contentConsistency: parsed.contentConsistency || 'good',\n            accountAge: parsed.accountAge || 'established',\n            profileCompleteness: parsed.profileCompleteness || 'complete'\n          },\n          confidence: parsed.confidence || 75\n        };\n      }\n    } catch (error) {\n      console.error('Failed to parse AI response:', error);\n    }\n\n    // Fallback if parsing fails\n    return this.fallbackAnalysis(metrics);\n  }\n  fallbackAnalysis(metrics) {\n    // Rule-based fallback analysis\n    const signals = {\n      followerQuality: metrics.followerToFollowingRatio < 0.1 ? 'suspicious' : 'normal',\n      engagementPattern: metrics.engagementRate > 8 || metrics.engagementRate < 0.5 ? 'suspicious' : 'organic',\n      contentConsistency: metrics.posts < 10 ? 'poor' : 'good',\n      accountAge: metrics.followers < 200 ? 'recent' : 'established',\n      profileCompleteness: Math.random() > 0.7 ? 'incomplete' : 'complete'\n    };\n    return {\n      signals,\n      confidence: 65\n    };\n  }\n  calculateBotScore(metrics, signals) {\n    let score = 0;\n\n    // Follower quality (30% weight)\n    if (signals.followerQuality === 'fake') score += 30;else if (signals.followerQuality === 'suspicious') score += 20;\n\n    // Engagement pattern (25% weight)\n    if (signals.engagementPattern === 'automated') score += 25;else if (signals.engagementPattern === 'suspicious') score += 15;\n\n    // Content consistency (20% weight)\n    if (signals.contentConsistency === 'poor') score += 20;else if (signals.contentConsistency === 'inconsistent') score += 12;\n\n    // Account age (15% weight)\n    if (signals.accountAge === 'very_new') score += 15;else if (signals.accountAge === 'recent') score += 8;\n\n    // Profile completeness (10% weight)\n    if (signals.profileCompleteness === 'minimal') score += 10;else if (signals.profileCompleteness === 'incomplete') score += 5;\n\n    // Metric-based adjustments\n    if (metrics.followerToFollowingRatio < 0.1) score += 10;\n    if (metrics.engagementRate > 8) score += 8;\n    if (metrics.engagementRate < 0.5) score += 5;\n    return Math.min(100, Math.max(0, score));\n  }\n  determineRiskLevel(botScore) {\n    if (botScore >= 70) return 'high';\n    if (botScore >= 40) return 'medium';\n    return 'low';\n  }\n  identifyRedFlags(metrics, signals) {\n    const flags = [];\n    if (signals.followerQuality === 'fake') {\n      flags.push('High percentage of fake followers detected');\n    }\n    if (signals.engagementPattern === 'automated') {\n      flags.push('Automated engagement patterns detected');\n    }\n    if (metrics.followerToFollowingRatio < 0.1) {\n      flags.push('Suspicious follower-to-following ratio');\n    }\n    if (metrics.engagementRate > 8) {\n      flags.push('Unrealistically high engagement rate');\n    }\n    if (metrics.engagementRate < 0.5) {\n      flags.push('Suspiciously low engagement rate');\n    }\n    if (signals.accountAge === 'very_new') {\n      flags.push('Very new account with high activity');\n    }\n    if (signals.contentConsistency === 'poor') {\n      flags.push('Inconsistent or low-quality content');\n    }\n    return flags;\n  }\n  generateRecommendations(riskLevel, redFlags) {\n    const recommendations = [];\n    switch (riskLevel) {\n      case 'high':\n        recommendations.push('❌ REJECT - High bot probability detected');\n        recommendations.push('Consider manual review if account seems legitimate');\n        break;\n      case 'medium':\n        recommendations.push('⚠️ CAUTION - Manual review recommended');\n        recommendations.push('Request additional verification');\n        break;\n      case 'low':\n        recommendations.push('✅ APPROVE - Low risk detected');\n        recommendations.push('Proceed with standard verification');\n        break;\n    }\n    if (redFlags.length > 0) {\n      recommendations.push(`Found ${redFlags.length} red flag(s) - see details above`);\n    }\n    return recommendations;\n  }\n  generateAnalysisId() {\n    return `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// Export singleton instance\nexport const botAnalyzer = new BotAnalyzer();","map":{"version":3,"names":["SocialMediaScraper","scrapeAccountData","account","platformMultipliers","instagram","followers","engagement","tiktok","youtube","twitter","multiplier","platform","baseFollowers","Math","floor","random","baseMetrics","following","posts","avgLikes","avgComments","engagementRate","followerToFollowingRatio","avgViews","targetEngagement","Promise","resolve","setTimeout","BotAnalyzer","constructor","scraper","analyzeAccount","startTime","Date","now","console","log","handle","metrics","aiAnalysis","performAIAnalysis","botScore","calculateBotScore","signals","riskLevel","determineRiskLevel","redFlags","identifyRedFlags","recommendations","generateRecommendations","processingTime","result","id","generateAnalysisId","confidence","analysisDate","toISOString","error","Error","message","apiKey","process","env","REACT_APP_GEMINI_API_KEY_1","fallbackAnalysis","genAI","GoogleGenerativeAI","model","getGenerativeModel","prompt","createAnalysisPrompt","generateContent","response","analysisText","text","parseAIResponse","toFixed","jsonMatch","match","parsed","JSON","parse","followerQuality","engagementPattern","contentConsistency","accountAge","profileCompleteness","score","min","max","flags","push","length","toString","substr","botAnalyzer"],"sources":["/Users/chrism2homefolder/Desktop/ClippIntelProject/src/components/botDetection.ts"],"sourcesContent":["// ClippIntell Bot Detection MVP - Core Bot Detection Engine\n\nimport { \n  BotAnalysisResult, \n  SocialAccount, \n  Platform, \n  BotSignals, \n  AccountMetrics, \n  BotRiskLevel \n} from '../assets/types';\n\n// Social media data scraper (mock for MVP)\nclass SocialMediaScraper {\n  async scrapeAccountData(account: SocialAccount): Promise<AccountMetrics> {\n    // In production, this would scrape real data\n    // For MVP, we'll generate realistic mock data based on platform\n    \n    const platformMultipliers = {\n      instagram: { followers: 1, engagement: 0.03 },\n      tiktok: { followers: 1.5, engagement: 0.08 },\n      youtube: { followers: 0.7, engagement: 0.05 },\n      twitter: { followers: 0.8, engagement: 0.02 }\n    };\n\n    const multiplier = platformMultipliers[account.platform];\n    \n    const baseFollowers = Math.floor(Math.random() * 30000 + 500) * multiplier.followers;\n    const baseMetrics = {\n      followers: Math.floor(baseFollowers),\n      following: Math.floor(Math.random() * 3000 + 100),\n      posts: Math.floor(Math.random() * 300 + 10),\n      avgLikes: 0,\n      avgComments: 0,\n      engagementRate: 0,\n      followerToFollowingRatio: 0\n    };\n\n    // Platform-specific metrics\n    if (account.platform === 'tiktok' || account.platform === 'youtube') {\n      baseMetrics.avgViews = Math.floor(baseMetrics.followers * (Math.random() * 0.3 + 0.1));\n    }\n\n    // Calculate realistic engagement\n    const targetEngagement = multiplier.engagement + (Math.random() - 0.5) * 0.02;\n    baseMetrics.avgLikes = Math.floor(baseMetrics.followers * targetEngagement);\n    baseMetrics.avgComments = Math.floor(baseMetrics.avgLikes * (Math.random() * 0.15 + 0.05));\n    baseMetrics.engagementRate = ((baseMetrics.avgLikes + baseMetrics.avgComments) / baseMetrics.followers) * 100;\n    baseMetrics.followerToFollowingRatio = baseMetrics.followers / baseMetrics.following;\n\n    // Simulate API delay\n    await new Promise(resolve => setTimeout(resolve, 1500 + Math.random() * 2000));\n\n    return baseMetrics;\n  }\n}\n\n// AI-powered bot detection analyzer\nexport class BotAnalyzer {\n  private scraper: SocialMediaScraper;\n\n  constructor() {\n    this.scraper = new SocialMediaScraper();\n  }\n\n  async analyzeAccount(account: SocialAccount): Promise<BotAnalysisResult> {\n    const startTime = Date.now();\n\n    try {\n      console.log(`Starting analysis for ${account.handle} on ${account.platform}`);\n\n      // Step 1: Scrape account metrics\n      const metrics = await this.scraper.scrapeAccountData(account);\n      console.log('Scraped metrics:', metrics);\n\n      // Step 2: AI analysis using Gemini\n      const aiAnalysis = await this.performAIAnalysis(account, metrics);\n      console.log('AI analysis complete:', aiAnalysis);\n\n      // Step 3: Calculate bot score and risk level\n      const botScore = this.calculateBotScore(metrics, aiAnalysis.signals);\n      const riskLevel = this.determineRiskLevel(botScore);\n\n      // Step 4: Generate recommendations\n      const redFlags = this.identifyRedFlags(metrics, aiAnalysis.signals);\n      const recommendations = this.generateRecommendations(riskLevel, redFlags);\n\n      const processingTime = (Date.now() - startTime) / 1000;\n\n      const result: BotAnalysisResult = {\n        id: this.generateAnalysisId(),\n        account,\n        botScore,\n        riskLevel,\n        signals: aiAnalysis.signals,\n        metrics,\n        redFlags,\n        recommendations,\n        confidence: aiAnalysis.confidence,\n        analysisDate: new Date().toISOString(),\n        processingTime\n      };\n\n      console.log('Analysis complete:', result);\n      return result;\n\n    } catch (error) {\n      console.error('Bot analysis failed:', error);\n      throw new Error(`Analysis failed for ${account.handle}: ${error.message}`);\n    }\n  }\n\n  private async performAIAnalysis(account: SocialAccount, metrics: AccountMetrics): Promise<{\n    signals: BotSignals;\n    confidence: number;\n  }> {\n    try {\n      const apiKey = process.env.REACT_APP_GEMINI_API_KEY_1;\n      if (!apiKey) {\n        console.log('No Gemini API key found, using fallback analysis');\n        return this.fallbackAnalysis(metrics);\n      }\n\n      const genAI = new GoogleGenerativeAI(apiKey);\n      const model = genAI.getGenerativeModel({ model: \"gemini-pro\" });\n\n      const prompt = this.createAnalysisPrompt(account, metrics);\n      console.log('Sending prompt to Gemini AI...');\n      \n      const result = await model.generateContent(prompt);\n      const response = await result.response;\n      const analysisText = response.text();\n\n      console.log('AI response received:', analysisText);\n\n      // Parse AI response\n      return this.parseAIResponse(analysisText, metrics);\n\n    } catch (error) {\n      console.error('AI analysis failed:', error);\n      // Fallback to rule-based analysis\n      console.log('Using fallback rule-based analysis');\n      return this.fallbackAnalysis(metrics);\n    }\n  }\n\n  private createAnalysisPrompt(account: SocialAccount, metrics: AccountMetrics): string {\n    return `\nAnalyze this ${account.platform} account for bot-like behavior:\n\nAccount: ${account.handle}\nPlatform: ${account.platform}\n\nMetrics:\n- Followers: ${metrics.followers}\n- Following: ${metrics.following}\n- Posts: ${metrics.posts}\n- Avg Likes: ${metrics.avgLikes}\n- Avg Comments: ${metrics.avgComments}\n- Engagement Rate: ${metrics.engagementRate.toFixed(2)}%\n- Follower/Following Ratio: ${metrics.followerToFollowingRatio.toFixed(2)}\n\nAnalyze these bot indicators and respond ONLY with valid JSON:\n\n{\n  \"followerQuality\": \"normal|suspicious|fake\",\n  \"engagementPattern\": \"organic|automated|suspicious\", \n  \"contentConsistency\": \"good|poor|inconsistent\",\n  \"accountAge\": \"established|recent|very_new\",\n  \"profileCompleteness\": \"complete|incomplete|minimal\",\n  \"confidence\": 85\n}\n`;\n  }\n\n  private parseAIResponse(response: string, metrics: AccountMetrics): {\n    signals: BotSignals;\n    confidence: number;\n  } {\n    try {\n      // Try to extract JSON from AI response\n      const jsonMatch = response.match(/\\{[\\s\\S]*\\}/);\n      if (jsonMatch) {\n        const parsed = JSON.parse(jsonMatch[0]);\n        return {\n          signals: {\n            followerQuality: parsed.followerQuality || 'normal',\n            engagementPattern: parsed.engagementPattern || 'organic',\n            contentConsistency: parsed.contentConsistency || 'good',\n            accountAge: parsed.accountAge || 'established',\n            profileCompleteness: parsed.profileCompleteness || 'complete'\n          },\n          confidence: parsed.confidence || 75\n        };\n      }\n    } catch (error) {\n      console.error('Failed to parse AI response:', error);\n    }\n\n    // Fallback if parsing fails\n    return this.fallbackAnalysis(metrics);\n  }\n\n  private fallbackAnalysis(metrics: AccountMetrics): {\n    signals: BotSignals;\n    confidence: number;\n  } {\n    // Rule-based fallback analysis\n    const signals: BotSignals = {\n      followerQuality: metrics.followerToFollowingRatio < 0.1 ? 'suspicious' : 'normal',\n      engagementPattern: metrics.engagementRate > 8 || metrics.engagementRate < 0.5 ? 'suspicious' : 'organic',\n      contentConsistency: metrics.posts < 10 ? 'poor' : 'good',\n      accountAge: metrics.followers < 200 ? 'recent' : 'established',\n      profileCompleteness: Math.random() > 0.7 ? 'incomplete' : 'complete'\n    };\n\n    return { signals, confidence: 65 };\n  }\n\n  private calculateBotScore(metrics: AccountMetrics, signals: BotSignals): number {\n    let score = 0;\n\n    // Follower quality (30% weight)\n    if (signals.followerQuality === 'fake') score += 30;\n    else if (signals.followerQuality === 'suspicious') score += 20;\n\n    // Engagement pattern (25% weight)\n    if (signals.engagementPattern === 'automated') score += 25;\n    else if (signals.engagementPattern === 'suspicious') score += 15;\n\n    // Content consistency (20% weight)\n    if (signals.contentConsistency === 'poor') score += 20;\n    else if (signals.contentConsistency === 'inconsistent') score += 12;\n\n    // Account age (15% weight)\n    if (signals.accountAge === 'very_new') score += 15;\n    else if (signals.accountAge === 'recent') score += 8;\n\n    // Profile completeness (10% weight)\n    if (signals.profileCompleteness === 'minimal') score += 10;\n    else if (signals.profileCompleteness === 'incomplete') score += 5;\n\n    // Metric-based adjustments\n    if (metrics.followerToFollowingRatio < 0.1) score += 10;\n    if (metrics.engagementRate > 8) score += 8;\n    if (metrics.engagementRate < 0.5) score += 5;\n\n    return Math.min(100, Math.max(0, score));\n  }\n\n  private determineRiskLevel(botScore: number): BotRiskLevel {\n    if (botScore >= 70) return 'high';\n    if (botScore >= 40) return 'medium';\n    return 'low';\n  }\n\n  private identifyRedFlags(metrics: AccountMetrics, signals: BotSignals): string[] {\n    const flags: string[] = [];\n\n    if (signals.followerQuality === 'fake') {\n      flags.push('High percentage of fake followers detected');\n    }\n    if (signals.engagementPattern === 'automated') {\n      flags.push('Automated engagement patterns detected');\n    }\n    if (metrics.followerToFollowingRatio < 0.1) {\n      flags.push('Suspicious follower-to-following ratio');\n    }\n    if (metrics.engagementRate > 8) {\n      flags.push('Unrealistically high engagement rate');\n    }\n    if (metrics.engagementRate < 0.5) {\n      flags.push('Suspiciously low engagement rate');\n    }\n    if (signals.accountAge === 'very_new') {\n      flags.push('Very new account with high activity');\n    }\n    if (signals.contentConsistency === 'poor') {\n      flags.push('Inconsistent or low-quality content');\n    }\n\n    return flags;\n  }\n\n  private generateRecommendations(riskLevel: BotRiskLevel, redFlags: string[]): string[] {\n    const recommendations: string[] = [];\n\n    switch (riskLevel) {\n      case 'high':\n        recommendations.push('❌ REJECT - High bot probability detected');\n        recommendations.push('Consider manual review if account seems legitimate');\n        break;\n      case 'medium':\n        recommendations.push('⚠️ CAUTION - Manual review recommended');\n        recommendations.push('Request additional verification');\n        break;\n      case 'low':\n        recommendations.push('✅ APPROVE - Low risk detected');\n        recommendations.push('Proceed with standard verification');\n        break;\n    }\n\n    if (redFlags.length > 0) {\n      recommendations.push(`Found ${redFlags.length} red flag(s) - see details above`);\n    }\n\n    return recommendations;\n  }\n\n  private generateAnalysisId(): string {\n    return `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n\n// Export singleton instance\nexport const botAnalyzer = new BotAnalyzer();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}