"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "createSDK", {
    enumerable: true,
    get: function() {
        return createSDK;
    }
});
const _utils = require("./utils");
function createSDK({ clientSchema, serverSchema, serverComplete, transport, timeout = 1000, timeouts, localAppId, remoteAppId, serverImplementation = {}, serverMiddleware }) {
    const callbacks = [];
    const keys = clientSchema?.options.map((option)=>option._def.shape().event._def.value) ?? [];
    const client = Object.fromEntries(keys.map((key)=>[
            key,
            async (req)=>{
                // We make event id unique so that we can fire many requests at the same time.
                const eventId = `${localAppId}:${key}:${(0, _utils.randomId)(8)}`;
                console.debug("[typed-transport] app. Created eventId", eventId);
                const responseData = new Promise((resolve, reject)=>{
                    // Timeout the request after the specified timeout
                    const customTimeout = timeouts?.[key];
                    const timeoutId = setTimeout(()=>{
                        const index = callbacks.findIndex((cb)=>cb.id === eventId);
                        if (index !== -1) callbacks.splice(index, 1);
                        if (serverComplete) {
                            console.debug("[typed-transport] app. Timeout error");
                            reject(new _utils.TimeoutError());
                        } else resolve(undefined);
                    }, customTimeout ?? timeout);
                    if (customTimeout && customTimeout > timeout && !serverComplete) {
                        const timeoutId = setTimeout(()=>{
                            const index = callbacks.findIndex((cb)=>cb.id === eventId);
                            if (index !== -1) callbacks.splice(index, 1);
                            resolve(undefined);
                        }, timeout);
                        callbacks.push({
                            id: `${eventId}:processing`,
                            resolve: ()=>clearTimeout(timeoutId)
                        });
                    }
                    callbacks.push({
                        id: eventId,
                        resolve: (data)=>{
                            clearTimeout(timeoutId);
                            resolve(data);
                        }
                    });
                });
                console.debug("[typed-transport] app sending event", {
                    eventId,
                    localAppId,
                    remoteAppId
                });
                await transport.send?.(eventId, req, {
                    localAppId,
                    remoteAppId
                });
                const data = await responseData;
                console.debug("[typed-transport] received response", data);
                return data;
            }
        ]));
    const cleanupRecv = transport.recv(async (event, dataAny)=>{
        const [app, key, _randomId, type] = event.split(":");
        if (app === localAppId) {
            // Here we are receiving a response from a request we made.
            const idx = callbacks.findIndex((cb)=>cb.id === event);
            if (idx === -1) return;
            const dataSchema = clientSchema?.optionsMap.get(key);
            if (!dataSchema) return;
            const cb = callbacks[idx];
            if (type === "processing") {
                cb.resolve(undefined);
            } else {
                const data = dataSchema.shape.response.parse(dataAny);
                callbacks.splice(idx, 1);
                cb.resolve(data);
            }
        } else if (app === remoteAppId) {
            if (serverImplementation === undefined) return;
            // Here we are responding to a request from a client.
            // final handler
            let handler = serverImplementation[key];
            // Build a linked list of middleware invocations that will call the final handler.
            if (serverMiddleware) {
                for(let i = serverMiddleware.length - 1; i >= 0; i--){
                    const middlewareDef = serverMiddleware[i];
                    const middleware = middlewareDef[key];
                    if (!middleware) continue;
                    const ref = handler;
                    handler = (data)=>middleware(data, ref);
                }
            }
            if (!handler) return;
            const dataSchema = serverSchema?.optionsMap.get(key);
            if (!dataSchema) return;
            const data = dataSchema.shape.request.parse(dataAny);
            // If our handler doesn't complete in 80% of the default message timeout, we send a message to the caller, saying that we are expecting an answer.
            const timeoutId = setTimeout(async ()=>{
                await transport.send(`${event}:processing`, {}, {
                    localAppId,
                    remoteAppId
                });
            }, 50);
            const response = await handler(data);
            clearTimeout(timeoutId);
            await transport.send(event, response, {
                localAppId,
                remoteAppId
            });
            return response;
        }
    }, {
        localAppId,
        remoteAppId
    });
    const cleanupFunctions = [];
    if (transport.cleanup) cleanupFunctions.push(transport.cleanup);
    if (cleanupRecv) cleanupFunctions.push(cleanupRecv);
    client._cleanupTransport = ()=>cleanupFunctions.forEach((fn)=>fn());
    return client;
}
