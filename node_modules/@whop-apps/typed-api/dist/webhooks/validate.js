"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "makeRequestValidator", {
    enumerable: true,
    get: function() {
        return makeRequestValidator;
    }
});
function makeRequestValidator({ key, headerName }) {
    const textEncoder = new TextEncoder();
    return async function validateWebhookRequest(req) {
        try {
            const body = await req.text();
            const header = req.headers.get(headerName);
            if (!header) return null;
            const [timestampStr, signatureStr] = header.split(",");
            const [, timestamp] = timestampStr.split("=");
            const [version, sentSignature] = signatureStr.split("=");
            const now = Math.round(Date.now() / 1000);
            if (Number.isNaN(Number.parseInt(timestamp)) || Math.abs(now - Number.parseInt(timestamp)) > 300) return null; // 5 minutes buffer interval
            const stringToHash = `${timestamp}.${body}`;
            const cryptoKey = await crypto.subtle.importKey("raw", textEncoder.encode(key), {
                name: "HMAC",
                hash: "SHA-256"
            }, false, [
                "sign"
            ]);
            const signatureBuffer = await crypto.subtle.sign({
                name: "HMAC",
                hash: "SHA-256"
            }, cryptoKey, textEncoder.encode(stringToHash));
            const signature = buf2hex(signatureBuffer);
            if (signature !== sentSignature && version !== "v1") return null;
            return JSON.parse(body);
        } catch (_error) {
            return null;
        }
    };
}
function buf2hex(buffer) {
    return [
        ...new Uint8Array(buffer)
    ].map((x)=>x.toString(16).padStart(2, "0")).join("");
}
