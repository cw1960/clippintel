import { type UserTokenData } from "@whop-apps/auth";
import { type FetchOptions } from "../app-component-fetch";
export type NAryOperator = "and" | "or";
export type UnaryOperator = "not";
export type Expression = [NAryOperator, ...Expression[]] | string | [UnaryOperator, Expression];
declare const TOKENS: readonly [{
    readonly type: "operator";
    readonly subtype: "and";
    readonly regex: RegExp;
}, {
    readonly type: "operator";
    readonly subtype: "or";
    readonly regex: RegExp;
}, {
    readonly type: "operator";
    readonly subtype: "not";
    readonly regex: RegExp;
}, {
    readonly type: "separator";
    readonly subtype: "separator";
    readonly regex: RegExp;
}, {
    readonly type: "terminator";
    readonly subtype: "terminator";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "authorized_user";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "product";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "user";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "membership";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "experience";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "line_item";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "authenticated";
    readonly regex: RegExp;
}, {
    readonly type: "primitive";
    readonly subtype: "public";
    readonly regex: RegExp;
}];
export type Primitive = Extract<(typeof TOKENS)[number], {
    type: "primitive";
}>["subtype"];
declare const primitiveArgumentParsers: {
    authorized_user: (str: string) => string;
    public: (_str: string) => "public";
    authenticated: (_str: string) => "authenticated";
};
export type PrimitiveCheckers<Req> = {
    [key in Exclude<Primitive, "public">]: (req: Req, id: key extends keyof typeof primitiveArgumentParsers ? ReturnType<(typeof primitiveArgumentParsers)[key]> : string) => Promise<boolean>;
};
export declare function parseAccessString(str: string): Expression;
export declare function or(...expressions: Expression[]): Expression;
export declare function and(...expressions: Expression[]): Expression;
export declare function not(expression: Expression): Expression;
export declare function authorizedUserOn(bizId: string): Expression;
export declare function makeAccessString(...expressions: Expression[]): string;
/**
 * Checks if the current user has access to the given access expression.
 * An access expression can be a string of a product_id, user_id, or membership_id,
 * Or it could be a more complex boolean expression of these primitives.
 * Use the helper functions `and`, `or` and `not` to construct these expressions.
 *
 * When called serverside (eg: from a NextJS server component), forward the request headers.
 * This means the request will be authenticated and the user's token will be available.
 *
 * When called clientside, this is not necessary, since the user's token is already available
 * in cookie header. Clientside this function only works when called from the browser within
 * the whop iframe through the whop app proxy.
 *
 * @example
 *
 * ```ts
 * import { headers } from 'next/header';
 *
 * export default function Page() {
 *   const access: boolean = await hasAccess({
 *     to: and(
 *       'prod_123',
 *       or(authorizedUserOn('biz_123'), 'user_123')),
 *     headers,
 *   });
 *   if (access) {
 *     // do something
 *   } else {
 *     // display an error, or redirect somewhere
 *   }
 * }
 * ```
 */
export declare function hasAccess({ throwOnError, to, req, token: rawToken, allowDefaultNextJsCache, customFetcher, ...init }: FetchOptions & {
    to: Expression;
    throwOnError?: boolean;
    token?: string;
    req?: Request;
    allowDefaultNextJsCache?: boolean;
    customFetcher?: {
        fetch: typeof fetch;
    };
}): Promise<boolean>;
export declare function isAuthenticated<ThrowOnError extends boolean = false>(opts?: {
    throwOnError?: ThrowOnError | undefined;
} & FetchOptions): Promise<ThrowOnError extends true ? {
    authenticated: true;
} & UserTokenData : ({
    authenticated: true;
} & UserTokenData) | null>;
export declare function evaluateAccessString<Req>({ req, str, checkers, maxCost, }: {
    str: string;
    req: Req;
    checkers: PrimitiveCheckers<Req>;
    maxCost?: number;
}): Promise<boolean>;
export declare function isAccessStringValid(str: string): boolean;
export {};
//# sourceMappingURL=index.d.ts.map