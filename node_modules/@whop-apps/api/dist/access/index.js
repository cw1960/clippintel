"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    parseAccessString: function() {
        return parseAccessString;
    },
    or: function() {
        return or;
    },
    and: function() {
        return and;
    },
    not: function() {
        return not;
    },
    authorizedUserOn: function() {
        return authorizedUserOn;
    },
    makeAccessString: function() {
        return makeAccessString;
    },
    hasAccess: function() {
        return hasAccess;
    },
    isAuthenticated: function() {
        return isAuthenticated;
    },
    evaluateAccessString: function() {
        return evaluateAccessString;
    },
    isAccessStringValid: function() {
        return isAccessStringValid;
    }
});
const _auth = require("@whop-apps/auth");
const _appcomponentfetch = require("../app-component-fetch");
const TOKENS = [
    {
        type: "operator",
        subtype: "and",
        regex: /^and-/
    },
    {
        type: "operator",
        subtype: "or",
        regex: /^or-/
    },
    {
        type: "operator",
        subtype: "not",
        regex: /^not-/
    },
    {
        type: "separator",
        subtype: "separator",
        regex: /^-/
    },
    {
        type: "terminator",
        subtype: "terminator",
        regex: /^_/
    },
    {
        type: "primitive",
        subtype: "authorized_user",
        regex: /^authorized-biz_[a-zA-Z0-9]+/
    },
    {
        type: "primitive",
        subtype: "product",
        regex: /^(prod|pass)_[a-zA-Z0-9]+/
    },
    {
        type: "primitive",
        subtype: "user",
        regex: /^user_[a-zA-Z0-9]+/
    },
    {
        type: "primitive",
        subtype: "membership",
        regex: /^mem_[a-zA-Z0-9]+/
    },
    {
        type: "primitive",
        subtype: "experience",
        regex: /^exp_[a-zA-Z0-9]+/
    },
    {
        type: "primitive",
        subtype: "line_item",
        regex: /^li_[a-zA-Z0-9]+/
    },
    // {
    //   type: 'primitive',
    //   subtype: 'authorized_product',
    //   regex: /^authorized-(prod|pass)_[a-zA-Z0-9]+/,
    // },
    {
        type: "primitive",
        subtype: "authenticated",
        regex: /^authenticated/
    },
    {
        type: "primitive",
        subtype: "public",
        regex: /^public/
    }
];
const PRIMITIVE_TOKENS = TOKENS.filter((t)=>t.type === "primitive");
const primitiveArgumentParsers = {
    authorized_user: (str)=>str.slice("authorized-".length),
    // authorized_product: (str: string) => str.slice('authorized-'.length),
    public: (_str)=>"public",
    authenticated: (_str)=>"authenticated"
};
const PRIMITIVE_EVAL_COST = {
    authorized_user: 1,
    experience: 1,
    membership: 1,
    product: 1,
    // authorized_product: 2,
    authenticated: 0,
    user: 0,
    public: 0,
    line_item: 1
};
function parsePrimitive(str) {
    const primitive = PRIMITIVE_TOKENS.find((t)=>str.match(t.regex));
    if (!primitive) throw Error(`Invalid primitive: ${str}`);
    const type = primitive.subtype;
    const value = type in primitiveArgumentParsers ? primitiveArgumentParsers[type](str) : str;
    return {
        type,
        original: str,
        value
    };
}
function tokenize(str) {
    const tokens = [];
    let rest = str;
    while(rest.length > 0){
        let matched = false;
        for (const token of TOKENS){
            const match = rest.match(token.regex);
            if (match) {
                tokens.push({
                    type: token.type,
                    subtype: token.subtype,
                    value: match[0]
                });
                rest = rest.slice(match[0].length);
                matched = true;
                break;
            }
        }
        if (!matched) throw Error(`Invalid token: ${rest}`);
    }
    return tokens;
}
function parseExpression(tokens) {
    const first = tokens.shift();
    if (!first) throw Error("Unexpected end of input.");
    if (first.type === "primitive") {
        return first.value;
    }
    if (first.type !== "operator") {
        throw Error(`Expected operator, got ${first.type} '${first.value}'`);
    }
    const operator = first.subtype;
    if (operator !== "and" && operator !== "or" && operator !== "not") throw Error("Invalid operator.");
    if (operator === "not") {
        const expression = parseExpression(tokens);
        parseClosingTerminator(tokens);
        return [
            operator,
            expression
        ];
    }
    const expressions = parseExpressionList(tokens);
    parseClosingTerminator(tokens);
    return [
        operator,
        ...expressions
    ];
}
function parseClosingTerminator(tokens) {
    const closingSemicolon = tokens.shift();
    if (!closingSemicolon) throw Error("Expected a closing terminator '_'. Got nothing");
    if (closingSemicolon.type !== "terminator") throw Error(`Expected a closing terminator '_'. Got ${closingSemicolon.value}`);
}
function parseExpressionList(tokens) {
    const expression = parseExpression(tokens);
    const peek = tokens[0];
    if (!peek || peek.type === "terminator") return [
        expression
    ];
    // biome-ignore lint/style/noNonNullAssertion: it cannot be null, we just checked
    const next = tokens.shift();
    if (next.type !== "separator") throw Error(`Expected a separator '-'. Got ${next.value}`);
    const rest = parseExpressionList(tokens);
    return [
        expression,
        ...rest
    ];
}
function simplifyExpression(expression) {
    if (typeof expression === "string") {
        return expression;
    }
    const [operator, ...expressions] = expression;
    if (operator === "not") {
        const next = simplifyExpression(expression[1]);
        if (typeof next === "string") return [
            "not",
            next
        ];
        if (next[0] === "not") return next[1];
        return [
            "not",
            next
        ];
    }
    if (expressions.length === 1) {
        return simplifyExpression(expressions[0]);
    }
    return [
        operator,
        ...expressions.map(simplifyExpression)
    ];
}
function parseAccessString(str) {
    const tokens = tokenize(str);
    const items = parseExpressionList(tokens);
    if (tokens.length > 0) throw Error(`Unexpected tokens: ${tokens[0].value}`);
    const expression = [
        "or",
        ...items
    ];
    return simplifyExpression(expression);
}
function or(...expressions) {
    return [
        "or",
        ...expressions
    ];
}
function and(...expressions) {
    return [
        "and",
        ...expressions
    ];
}
function not(expression) {
    return [
        "not",
        expression
    ];
}
function authorizedUserOn(bizId) {
    return `authorized-${bizId}`;
}
function expressionToString(expr) {
    const expression = simplifyExpression(expr);
    if (typeof expression === "string") {
        return expression;
    }
    const [operator, ...expressions] = expression;
    if (operator === "not") {
        return `${operator}-${expressionToString(expression[1])}_`;
    }
    const args = expressions.map(expressionToString).join("-");
    return `${operator}-${args}_`;
}
function makeAccessString(...expressions) {
    return expressions.map(expressionToString).join("-");
}
async function hasAccess({ throwOnError, to, req, token: rawToken, allowDefaultNextJsCache, customFetcher, ...init }) {
    try {
        // TODO: inspect the access string and combine with existence of token to ensure that
        // we don't make a request if we know the user is not logged in and is trying to access
        // a resource that requires authentication
        const accessString = makeAccessString(to);
        if (accessString === "public") return true;
        const token = rawToken ?? (init.headers ? (0, _auth.getTokenFromHeaders)(init.headers) : undefined) ?? (req ? (0, _auth.getTokenFromRequest)(req) : undefined);
        // Some optimisations
        // DISABLED 2024-03-08. We cannot do this because an experience might be "public"
        // if (!token) return false; // User is not authenticated
        // const user = await validateToken({ token, dontThrow: true });
        // if (!user) return false; // Invalid token
        const response = await (0, _appcomponentfetch.appComponentFetch)({
            token,
            component: "access",
            path: `/check/${accessString}`,
            allowDefaultNextJsCache,
            customFetcher,
            ...init
        });
        if (!response.ok) throw Error("Access check failed.");
        const { access } = await response.json();
        return access;
    } catch (error) {
        if (throwOnError) throw error;
        console.error(error);
        return false;
    }
}
async function isAuthenticated(opts) {
    const { throwOnError, ...init } = opts ?? {};
    try {
        const response = await (0, _appcomponentfetch.appComponentFetch)({
            component: "access",
            path: "/authenticated",
            ...init
        });
        if (!response.ok) throw Error("Access check failed.");
        const data = await response.json();
        return data;
    } catch (error) {
        if (throwOnError) throw error;
        return null;
    }
}
function getPrimitives(expression) {
    if (typeof expression === "string") {
        return [
            expression
        ];
    }
    const [, ...expressions] = expression;
    return [
        ...new Set(expressions.flatMap(getPrimitives))
    ];
}
function evaluateExpression(expression, values) {
    const getValue = (key)=>values[key] ?? false;
    if (typeof expression === "string") {
        return getValue(expression);
    }
    const [operator, ...expressions] = expression;
    if (operator === "not") {
        return !evaluateExpression(expression[1], values);
    }
    if (operator === "and") {
        return expressions.every((e)=>evaluateExpression(e, values));
    }
    if (operator === "or") {
        return expressions.some((e)=>evaluateExpression(e, values));
    }
    return false;
}
async function evaluateAccessString({ req, str, checkers, maxCost = 6 }) {
    const expr = parseAccessString(str);
    const primitives = getPrimitives(expr).map(parsePrimitive);
    const cost = primitives.reduce((acc, p)=>acc + PRIMITIVE_EVAL_COST[p.type], 0);
    if (cost > maxCost) {
        throw Error(`Access string is too complex. Max cost is ${maxCost}, got ${cost}. Cost is derived from the number of primitives in the access string. (excluding user ids which are free to compute)`);
    }
    const values = Object.fromEntries(await Promise.all(primitives.map(async (p)=>{
        if (p.type === "public") return [
            p.original,
            true
        ];
        const value = await checkers[p.type](req, p.value).catch(()=>false);
        return [
            p.original,
            value
        ];
    })));
    return evaluateExpression(expr, values);
}
function isAccessStringValid(str) {
    try {
        parseAccessString(str);
        return true;
    } catch  {
        return false;
    }
}
